<!DOCTYPE html><html class="light page-post"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><title>A Closer Look at Go (golang) Type System. | Ankur Anand</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link rel="canonical" href="http://blog.ankuranand.com/2018/11/29/a-closer-look-at-go-golang-type-system/"><meta name="title" content="A Closer Look at Go (golang) Type System."><meta name="referrer" content="unsafe-url"><meta name="author" content="Ankur Anand"><meta name="keywords" content="go,golang,typesystem,types,"><meta name="description" content="A detailed look of the Go type system, with examplesLet’s begin by asking a fundamental question.Why we need a type?Before answering that, we need to look at some of the primitive abstracted layers of"><meta name="keywords" content="go,golang,typesystem,types"><meta property="og:type" content="article"><meta property="og:title" content="A Closer Look at Go (golang) Type System."><meta property="og:url" content="http://blog.ankuranand.com/2018/11/29/a-closer-look-at-go-golang-type-system/"><meta property="og:site_name" content="Ankur Anand"><meta property="og:description" content="A detailed look of the Go type system, with examplesLet’s begin by asking a fundamental question.Why we need a type?Before answering that, we need to look at some of the primitive abstracted layers of"><meta property="og:locale" content="en"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2000/1*rloLcZT1LTvGZ_NDVsLTHw.jpeg"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2000/1*VBvnwy7fYgbdoFGXb9Qg8w.gif"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2000/1*DsSLeUlDhbQFm_68AqoedQ.png"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2536/1*psoGJnlTuzpCUFgzuI5L3A.png"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2298/1*SALLWF9QMMYBmv5irMPy0w.png"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2000/1*e6YLl8aFgV04MOUFAfy_Rw.png"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2168/1*nmoYe21euF8VqSMOEqkA3A.png"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2074/1*RRtpi00SuC7fRqzfB0ePIA.png"><meta property="og:updated_time" content="2019-06-09T15:56:21.681Z"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="A Closer Look at Go (golang) Type System."><meta name="twitter:description" content="A detailed look of the Go type system, with examplesLet’s begin by asking a fundamental question.Why we need a type?Before answering that, we need to look at some of the primitive abstracted layers of"><meta name="twitter:image" content="https://cdn-images-1.medium.com/max/2000/1*rloLcZT1LTvGZ_NDVsLTHw.jpeg"><meta name="twitter:creator" content="@in_aanand"><meta property="article:author" content="https://ankuranand.com/"><meta name="robots" content="index, follow"><link rel="icon" href="/images/favicon.png"><link href="/css/styles.css?v=c114cbeddx" rel="stylesheet"><link rel="stylesheet" href="/css/personal-style.css"><script type="text/javascript">!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject="ga",e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="//www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script"),ga("create","UA-76643336-2","auto"),ga("send","pageview")</script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css"></head></html><body><span id="toolbox-mobile" class="toolbox-mobile">Blog</span><div class="post-header CENTER"><div class="toolbox"><a class="toolbox-entry" href="/"><span class="toolbox-entry-text">Blog</span> <i class="icon-angle-down"></i> <i class="icon-home"></i></a><ul class="list-toolbox"><li class="item-toolbox"><a class="CIRCLE" href="https://ankuranand.com" rel="noopener noreferrer" target="_self">About</a></li><li class="item-toolbox"><a class="CIRCLE" href="/atom.xml" rel="noopener noreferrer" target="_blank">RSS</a></li><li class="item-toolbox"><a class="CIRCLE" href="/search/" rel="noopener noreferrer" target="_self">Search</a></li></ul></div></div><div class="content content-post CENTER"><article id="post-a-closer-look-at-go-golang-type-system" class="article article-type-post" itemprop="blogPost"><header class="article-header"><h1 class="post-title">A Closer Look at Go (golang) Type System.</h1><div class="article-meta"><span><i class="icon-calendar"></i> <span>2018.11.29</span> </span><span class="article-author"><i class="icon-user"></i> <span>Ankur Anand</span> </span><span class="article-category"><i class="icon-list"></i> <a class="article-category-link" href="/categories/golang/">golang</a></span></div></header><div class="article-content"><p>A detailed look of the Go type system, with examples</p><p>Let’s begin by asking a fundamental question.</p><h2 id="Why-we-need-a-type"><a href="#Why-we-need-a-type" class="headerlink" title="Why we need a type?"></a>Why we need a type?</h2><p>Before answering that, we need to look at some of the primitive abstracted layers of programming languages that we don’t usually deal with.</p><p><strong>How close can we get to a machine representation of data?</strong></p><p><img src="https://cdn-images-1.medium.com/max/2000/1*rloLcZT1LTvGZ_NDVsLTHw.jpeg" alt="Binary 0s and 1s"></p><p><strong>Binary zeroes and 1’s.</strong> That’s what a machine understands.</p><p>But does it make sense to us? It doesn’t to me until I’m someone who can see something like this. Matrix fanboy, anyone?</p><p><em>What happens when you attain nirvana in computer science. (image source Martix movie)</em><br><img src="https://cdn-images-1.medium.com/max/2000/1*VBvnwy7fYgbdoFGXb9Qg8w.gif" alt="What happens when you attain nirvana in computer science. (image source Martix movie)"></p><p>So we can abstract these binary 0’s and 1’s and move one step up in the ladder.</p><p>Consider this assembly fragment:</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*DsSLeUlDhbQFm_68AqoedQ.png" alt></p><p>Can you tell the types of data in registers R1, R2, and R3?</p><p>You <strong>might hope</strong> that they’re integers because at the assembly language level it cannot be determined. There’s nothing that prevents R1, R2, and R3 from having arbitrary types. They’re just a bunch of registers with 0’s and 1’s in them. The add operation will be happy to take them and add them up even if it doesn’t make sense and produce a bit pattern that is then stored.</p><p>So this notion of <strong>type </strong>starts at an, even more, higher abstraction, in a higher level language like C, Go, Java, Python, andJavaScript , and is the feature of language itself.</p><p>Some languages perform this type checking at the runtime, while some perform it at the compile time.</p><h2 id="So-what-is-a-type"><a href="#So-what-is-a-type" class="headerlink" title="So what is a type?"></a>So what is a type?</h2><p>The notion of type does vary from programming language to programming language. It can be expressed in a number of different ways, but roughly they all have some sort of consensus.</p><p><strong>1.</strong> A type is a set of values.</p><p><strong>2.</strong> A set of operations on those values. For example, with a type of integer we can add ( + ) and subtract ( — ). On the type of string we can concatenate, perform empty checks, and so forth.</p><p><strong>3.</strong> Typing is checked by the compiler and/or runtime to ensure the integrity of the data and interpret the data as meant by the developer.</p><p><strong>So a language type system specifies which operations are valid for which types.</strong></p><p>The goal of type checking is to ensure that operations are used only with the correct types and the rules of the type system are respected by the program. This is done either by the compiler when converting the code, or by the runtime while executing the code. By doing this, type checking enforces the intended interpretation of values. Nothing else is going to check — once we get to machine level code, it’s just a lot of 0’s and 1’s. The machine will be happy to do whatever operations we tell it on those 0’s and 1’s.</p><p>A type system is there to enforce that the intended interpretations of those bit patterns. For example, it makes sure that a bit pattern for integers doesn’t have any non-integer operation performed on that — this would get something that is meaningless.</p><p>A type system consists of :</p><p><strong>1.</strong> <strong>Basic types — </strong>Included in the programming language and available to any program written in that language. Go has various basic types(int8 , uint8 ( byte ), int16 , uint16 , int32 ( rune ), uint32) etc.</p><p><strong>2.</strong> <strong>Type constructors — </strong>Way for a programmer to define new types.<br>Eg. Pointer to T, where T is a Type or Struct {a: T}</p><p><strong>3.</strong> <strong>Type Inference — </strong>The compiler can infer the type of a variable or a function without us having to explicitly specify it. <em>Go has Uni-directional type inference.</em></p><p><strong>4.</strong> <strong>Type Compatibility — </strong>Which assignments are allowed by the type system? a int; b int8; a = b; ?<br>How to determine if two types are equal? In Go <a href="https://golang.org/ref/spec#Assignability" target="_blank" rel="noopener">assignability</a> is what mostly determines whether types can be used interchangeably. We will look at this later in details.</p><h2 id="The-type-system-in-Go"><a href="#The-type-system-in-Go" class="headerlink" title="The type system in Go"></a>The type system in Go</h2><p>There are some fundamental specs that govern the type system In Go. We will be looking at some of the important ones.</p><p>But, instead of just putting down all of the concepts at once, here I will have different examples covering some fundamental concepts of the Go type system. I will walk you through these examples while explaining some of the essential concepts.</p><p>Have a moment and look at these code snippets. Which one of these will compile, and why or why not?</p><p><img src="https://cdn-images-1.medium.com/max/2536/1*psoGJnlTuzpCUFgzuI5L3A.png" alt="type system in go"><br><img src="https://cdn-images-1.medium.com/max/2298/1*SALLWF9QMMYBmv5irMPy0w.png" alt="Type system in Go."></p><p>I would like you to note down your answer and reasons, so in the end, we can reason about this together.</p><h3 id="Named-types"><a href="#Named-types" class="headerlink" title="Named types"></a>Named types</h3><p>Types with names such as int, int64, float32, string, and boolare predeclared. <strong>All of the predeclared boolean, numeric and string types are named types.</strong></p><p>Also, any type that we create using the type declaration is a named type.<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> <span class="comment">// named type</span></span><br><span class="line"><span class="keyword">type</span> myInt <span class="keyword">int</span> <span class="comment">// named type</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">bool</span> <span class="comment">// named type</span></span><br></pre></td></tr></table></figure><p></p><p><strong>A named, defined types are always different from any other type.</strong></p><h3 id="Unnamed-types"><a href="#Unnamed-types" class="headerlink" title="Unnamed types"></a>Unnamed types</h3><p><strong>Composite types</strong> — array, struct, pointer, function, interface, slice, map, and channel types — are all unnamed types.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[]<span class="keyword">string</span> <span class="comment">// unnamed type</span></span><br><span class="line"><span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">// unnamed type</span></span><br><span class="line">[<span class="number">10</span>]<span class="keyword">int</span> <span class="comment">// unnamed type</span></span><br></pre></td></tr></table></figure><p>The type literal above (a <strong>literal</strong> is a notation for representing a fixed value) describe how composite types are to be structured, it’s says nothing about its name.</p><h3 id="Underlying-types"><a href="#Underlying-types" class="headerlink" title="Underlying types"></a>Underlying types</h3><p>Each type, T , has an underlying type.</p><p>If T is one of the predeclared boolean, numeric, or string types, or a type literal, the corresponding underlying type is T itself. Otherwise, T’s underlying type is the one which T refers to in its <a href="https://golang.org/ref/spec#Type_declarations" target="_blank" rel="noopener">type declaration</a>.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*e6YLl8aFgV04MOUFAfy_Rw.png" alt></p><p>So type by line number:</p><ul><li><p><strong>3 and 8:</strong> We have a predeclared type of string , so the underlying type will be T itself — string</p></li><li><p><strong>5 and 7:</strong> We have a type literal, so the underlying type will be T itself — map[string]int and *N pointer. <strong>Note</strong> these type literals are also unnamed type</p></li><li><p><strong>4, 6, and 10:</strong> T’s underlying type is the underlying type which T refers to in its <a href="https://golang.org/ref/spec#Type_declarations" target="_blank" rel="noopener">type declaration</a>. For example,B refers to A, hence B is a string.</p></li></ul><p>The case that needs to be looked again is on line number<strong> 9, </strong>type T map[S]int.</p><p>S has an underlying type of string. Shouldn’t the underlying type of type <code>T map[S]int</code> be map[string]int instead of map[S]int? Here we are talking about the <strong>underlying unnamed type map[S]int </strong>and underlying type stop at first unnamed type ( or as the specs say “<em>If T is a type literal, the corresponding underlying type is T itself</em>” ).</p><p>You might be wondering why I’m putting so much stress on these specs of unnamed type, named (defined) type and underlying type. The reason is that these play an important role in the specs that we are going to discuss further. These help us understand why the code snippets posted above will compile, or will not even when the intents are mostly same.</p><h3 id="Assignability"><a href="#Assignability" class="headerlink" title="Assignability"></a>Assignability</h3><p>This occurs when a variable v can be assigned to a variable to type T.</p><p><img src="https://cdn-images-1.medium.com/max/2168/1*nmoYe21euF8VqSMOEqkA3A.png" alt="Assignability specs Golang."><em>Assignability specs Golang.</em></p><p>While the conditions are self-explanatory, let’s look at one of the rules.</p><p><strong>Rule:</strong> When assigning, both should have the same underlying type, and at least one of then is not a named type.</p><p>Let’s look at the snippet problem of Figures 4 and 5 again.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> aInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">	<span class="keyword">var</span> ai aInt = <span class="number">100</span></span><br><span class="line">	i = ai</span><br><span class="line">	printAiType(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printAiType</span><span class="params">(ai aInt)</span></span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(ai)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>So the above code will not compile and will give us a compile-time error.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8:4: cannot use ai (type aInt) as type int in assignment</span><br><span class="line">9:13: cannot use i (type int) as type aInt in argument to printAiType</span><br></pre></td></tr></table></figure><p></p><p><strong>Reason:</strong> the i is of a named type int and ai is of a named type aInt , even though their underlying type is the same.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyMap <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">var</span> mMap MyMap</span><br><span class="line">	mMap = m</span><br><span class="line">	printMyMapType(mMap)</span><br><span class="line">	<span class="built_in">print</span>(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMyMapType</span><span class="params">(mMap MyMap)</span></span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(mMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>snippet4 above <strong>will</strong> compile, <strong>because</strong> m is of unnamed type and the underlying type of both m and mMap is the same.</p><h3 id="Type-Conversion"><a href="#Type-Conversion" class="headerlink" title="Type Conversion"></a>Type Conversion</h3><p><img src="https://cdn-images-1.medium.com/max/2074/1*RRtpi00SuC7fRqzfB0ePIA.png" alt="Type conversion specs."><em>Type conversion specs.</em></p><p>Look at the code from Figure 3.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Meter <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Centimeter <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> cm Centimeter = <span class="number">1000</span></span><br><span class="line">	<span class="keyword">var</span> m Meter</span><br><span class="line">	m = Meter(cm)</span><br><span class="line">	<span class="built_in">print</span>(m)</span><br><span class="line">	cm = Centimeter(m)</span><br><span class="line">	<span class="built_in">print</span>(cm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The above code <strong>will</strong> compile as <strong>both</strong> Meter and Centimeter are of integers type<strong> </strong>and their underlying type value are convertable between each other.</p><p>Before we look into the code from Figures 1 and 2, let’s take a look at one more fundamental spec governing the type system in Go.</p><h3 id="Type-identity"><a href="#Type-identity" class="headerlink" title="Type identity"></a>Type identity</h3><p><strong>Two types are either identical or different.</strong></p><p>In general type system, there are two standard ways to determine whether two types are considered the same: <strong>name equivalence</strong> and <strong>structural equivalence</strong>.</p><p><strong>Name equivalence</strong> is the most straightforward: <em>two types are equal if, and only if, they have the same name.</em></p><p>In Go<strong>, A defined type is always different from any other type (named equivalence)</strong>.</p><p><strong>Structural equivalence:</strong> <em>two types are equal if, and only if, they have the same “structure”</em>, which can be interpreted in different ways.</p><p>In Go, two types are identical if their underlying type literals are <strong>structurally equivalent and are not of named types</strong>.</p><p>So even predeclared named/defined types such as int and int64 are not identical. Also, the assignability of interfaces types in Go is determined by the <a href="https://en.wikipedia.org/wiki/Structural_type_system" target="_blank" rel="noopener">Structural Type System</a>. <strong>There is No Duck Typing in Go</strong>.</p><div class="twitter-wrapper"><blockquote class="twitter-tweet"><a href="https://twitter.com/in_aanand/status/1072476894308773888" target="_blank" rel="noopener"></a></blockquote></div><script async defer src="//platform.twitter.com/widgets.js" charset="utf-8"></script><p>So, looking at the rule for conversion for struct:</p><p><strong>Rule:</strong> ignoring struct tags, x’s type and T have identical underlying types.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Meter <span class="keyword">struct</span> &#123;</span><br><span class="line">	value <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Centimeter <span class="keyword">struct</span> &#123;</span><br><span class="line">	value <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cm := Centimeter&#123;</span><br><span class="line">		value: <span class="number">1000</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> m Meter</span><br><span class="line">	m = Meter(cm)</span><br><span class="line">	<span class="built_in">print</span>(m.value)</span><br><span class="line">	cm = Centimeter(m)</span><br><span class="line">	<span class="built_in">print</span>(cm.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Notice the term <strong>identical underlying types</strong>. Since the underlying type of field Meter.value is of int64 and field Centimeter.value is of int32 they are <strong>not identical</strong> as <strong>a</strong> <strong>defined type is always different from any other type</strong>.</p><p>So we will get the compilation error for the snippet code from Figure 2.</p><p>The snippet code of Figure 1:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Meter <span class="keyword">struct</span> &#123;</span><br><span class="line">	value <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Centimeter <span class="keyword">struct</span> &#123;</span><br><span class="line">	value <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cm := Centimeter&#123;</span><br><span class="line">		value: <span class="number">1000</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> m Meter</span><br><span class="line">	m = Meter(cm)</span><br><span class="line">	<span class="built_in">print</span>(m.value)</span><br><span class="line">	cm = Centimeter(m)</span><br><span class="line">	<span class="built_in">print</span>(cm.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>has the underlying type of field Meter.value to be int64 and the field Centimeter.value isint64. So they are <strong>identical</strong>. Hence there is conversion without any compilation error.</p><p>I hope this article proves helpful to you at providing some insights into the Go type system, as it’s has been for me while writing.</p></div></article><p class="article-content share_center"><strong>Learned something? Share 👏 to help others find this article.</strong></p><div class="share share_center"><ul class="share__list"><li class="share__item"><a href="https://twitter.com/share?text=A Closer Look at Go (golang) Type System.&amp;url=http://blog.ankuranand.com/2018/11/29/a-closer-look-at-go-golang-type-system/index.html&amp;via=in_aanand" target="_blank"><svg class="icon share__icon share__icon--twitter"><use xlink:href="#icon-twitter" xmlns:xlink="https://www.w3.org/1999/xlink"/></svg> Tweet this</a></li></ul></div><div class="box-prev-next clearfix" style="margin-top:10px"><a class="show pull-left" href="/2018/09/29/diving-deep-into-the-golang-channels/"><i class="icon icon-angle-left"></i> </a><a class="show pull-right" href="/2019/02/20/a-visual-guide-to-golang-memory-allocator-from-ground-up/"><i class="icon icon-angle-right"></i></a></div></div><a id="backTop" class="back-top"><i class="icon-angle-up"></i></a><div class="modal" id="modal"><span id="cover" class="cover hide"></span><div id="modal-dialog" class="modal-dialog hide-dialog"><div class="modal-header"><span id="close" class="btn-close">Close</span></div><hr><div class="modal-body"><ul class="list-toolbox"><li class="item-toolbox"><a class="CIRCLE" href="https://ankuranand.com" rel="noopener noreferrer" target="_self">About</a></li><li class="item-toolbox"><a class="CIRCLE" href="/atom.xml" rel="noopener noreferrer" target="_blank">RSS</a></li><li class="item-toolbox"><a class="CIRCLE" href="/search/" rel="noopener noreferrer" target="_self">Search</a></li></ul></div></div></div><div class="fexo-comments comments-post"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><script>const gitalk = new Gitalk({
  clientID: 'Infinity',
  clientSecret: '9ac2991775db990e81299dfa99a114395b58de3a',
  repo: 'blog',
  owner: 'ankur-anand',
  id: location.pathname.split('/')[4].substring(0, 45),
  // id: location.pathname,
  admin: ['ankur-anand'],
  labels: ['gicomment'],
  // facebook-like distraction free mode
  distractionFreeMode: false
})
gitalk.render('gitalk-container')</script></div><script type="text/javascript">function loadScript(e,t){var a=document.createElement("script");a.type="text/javascript",a.readyState?a.onreadystatechange=function(){"loaded"!=a.readyState&&"complete"!=a.readyState||(a.onreadystatechange=null,t())}:a.onload=function(){t()},a.src=e,document.getElementsByTagName("head")[0].appendChild(a)}window.onload=function(){loadScript("/js/bundle.js?235683",function(){})}</script><div class="svg-holder"><svg xmlns="https://www.w3.org/2000/svg"><symbol viewbox="0 0 32 32" id="icon-twitter"><title>twitter</title><path d="M31,6.696c-1.103,0.489-2.291,0.82-3.536,0.969c1.271-0.762,2.247-1.968,2.708-3.404c-1.189,0.705-2.508,1.218-3.909,1.493
          c-1.122-1.196-2.723-1.943-4.493-1.943c-3.398,0-6.154,2.755-6.154,6.154c0,0.483,0.055,0.953,0.159,1.402
          C10.66,11.111,6.125,8.66,3.089,4.937C2.561,5.846,2.256,6.902,2.256,8.031c0,2.135,1.086,4.019,2.737,5.123
          c-1.009-0.031-1.957-0.309-2.786-0.77c-0.002,0.025-0.002,0.052-0.002,0.078c0,2.982,2.122,5.469,4.937,6.034
          c-0.517,0.142-1.061,0.217-1.622,0.217c-0.396,0-0.782-0.039-1.158-0.112c0.784,2.444,3.057,4.225,5.75,4.274
          c-2.105,1.651-4.761,2.635-7.645,2.635c-0.496,0-0.985-0.029-1.467-0.086c2.723,1.746,5.958,2.765,9.434,2.765
          c11.321,0,17.512-9.379,17.512-17.512c0-0.268-0.005-0.533-0.018-0.796C29.131,9.014,30.174,7.93,31,6.696L31,6.696z"/></symbol></svg></div><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script></body>