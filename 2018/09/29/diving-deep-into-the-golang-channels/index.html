<!DOCTYPE html><html class="light page-post"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><title>Diving deep into the golang channels | Ankur Anand</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link rel="canonical" href="http://blog.ankuranand.com/2018/09/29/diving-deep-into-the-golang-channels/"><meta name="title" content="Diving deep into the golang channels"><meta name="referrer" content="unsafe-url"><meta name="author" content="Ankur Anand"><meta name="keywords" content="go,golang,internals,channels,"><meta name="description" content="An ‚Äúins and out‚Äù of the internal implementation of the Golang channels and its related operations.Concurrency in Golang is much more than just syntax.It a design pattern.A pattern that is a repeatable"><meta name="keywords" content="go,golang,internals,channels"><meta property="og:type" content="article"><meta property="og:title" content="Diving deep into the golang channels"><meta property="og:url" content="http://blog.ankuranand.com/2018/09/29/diving-deep-into-the-golang-channels/"><meta property="og:site_name" content="Ankur Anand"><meta property="og:description" content="An ‚Äúins and out‚Äù of the internal implementation of the Golang channels and its related operations.Concurrency in Golang is much more than just syntax.It a design pattern.A pattern that is a repeatable"><meta property="og:locale" content="en"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2000/1*esw_FDWZXB-3o2gA4buRpA.jpeg"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2000/1*cZY2BoVrw7OSpl2-r-g5yA.jpeg"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2000/1*W6AijkK0xecNtW_jvRU79Q.png"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2000/1*fiFgoUaJ8nV-SQtEjRv2-w.jpeg"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2000/1*tRvxKBqmSjhnWAh1X0o2kA.jpeg"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2000/1*6QwJEx8opvaNzabRtHMa9A.jpeg"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2000/1*F16kjMMl6Y9W7IYWNAHXrw.jpeg"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2000/1*HZyaOxBmRRopvrnhrx90VQ.jpeg"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2476/1*y9l_mrfI80ga6RXiTezREQ.png"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2472/1*q0fyvZEoGKhFhYDgCtPUDg.png"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2000/1*oqyZV9Ia-MraRGqvK3WaCg.jpeg"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2904/1*h7Gv5MhYHL2qrAkhtFG_NQ.png"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2000/1*QVu5G0iXTwA5emKOoKvVxA.jpeg"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2432/1*wMt7zNZk8E5S0nKBstGIIA.png"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2000/1*fKqlJBh2QhVlGtlWd1ImrQ.png"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2000/1*zVskwl0V0NeSqBFkQ6DYDw.png"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2000/1*-bYEd5Z0SyJlREIgayXmxA.png"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2000/1*zgflB5OPpySo9nlJG_PhLQ.png"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2000/1*eP36utLSm2q8kBxMBCuWJQ.png"><meta property="og:updated_time" content="2019-06-09T15:56:26.309Z"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Diving deep into the golang channels"><meta name="twitter:description" content="An ‚Äúins and out‚Äù of the internal implementation of the Golang channels and its related operations.Concurrency in Golang is much more than just syntax.It a design pattern.A pattern that is a repeatable"><meta name="twitter:image" content="https://cdn-images-1.medium.com/max/2000/1*esw_FDWZXB-3o2gA4buRpA.jpeg"><meta name="twitter:creator" content="@in_aanand"><meta property="article:author" content="https://ankuranand.com/"><meta name="robots" content="index, follow"><link rel="icon" href="/images/favicon.png"><link href="/css/styles.css?v=c114cbeddx" rel="stylesheet"><link rel="stylesheet" href="/css/personal-style.css"></head></html><body><span id="toolbox-mobile" class="toolbox-mobile">Blog</span><div class="post-header CENTER"><div class="toolbox"><a class="toolbox-entry" href="/"><span class="toolbox-entry-text">Blog</span> <i class="icon-angle-down"></i> <i class="icon-home"></i></a><ul class="list-toolbox"><li class="item-toolbox"><a class="CIRCLE" href="https://ankuranand.com" rel="noopener noreferrer" target="_self">About</a></li><li class="item-toolbox"><a class="CIRCLE" href="/atom.xml" rel="noopener noreferrer" target="_blank">RSS</a></li><li class="item-toolbox"><a class="CIRCLE" href="/search/" rel="noopener noreferrer" target="_self">Search</a></li></ul></div></div><div class="content content-post CENTER"><article id="post-diving-deep-into-the-golang-channels" class="article article-type-post" itemprop="blogPost"><header class="article-header"><h1 class="post-title">Diving deep into the golang channels</h1><div class="article-meta"><span><i class="icon-calendar"></i> <span>2018.09.29</span> </span><span class="article-author"><i class="icon-user"></i> <span>Ankur Anand</span> </span><span class="article-category"><i class="icon-list"></i> <a class="article-category-link" href="/categories/golang/">golang</a></span></div></header><div class="article-content"><p>An ‚Äúins and out‚Äù of the internal implementation of the Golang channels and its related operations.</p><p>Concurrency in Golang is much more than just syntax.</p><blockquote><p>It a design pattern.</p></blockquote><p>A pattern that is a repeatable solution to a commonly occurring problem while working with concurrency, because even</p><blockquote><p>Concurrency Needs to be Synchronized.</p></blockquote><p>And Go relies on a concurrency model called CSP (Communicating Sequential Processes),to achieve this pattern of synchronization through Channel. Go core philosophy for concurrency is</p><p><em>Do not communicate by sharing memory; instead, share memory by communicating.</em></p><p>But Go also trusts you to do the right thing. So Rest of the post will try to open this envelope of Go philosophy and how channels ‚Äî using a queue to achieve the same.</p><h2 id="What-it-takes-to-be-a-Channel"><a href="#What-it-takes-to-be-a-Channel" class="headerlink" title="What it takes to be a Channel."></a>What it takes to be a Channel.</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goRoutineA</span><span class="params">(a &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    val := &lt;-a</span><br><span class="line">    fmt.Println(<span class="string">"goRoutineA received the data"</span>, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> goRoutineA(ch)</span><br><span class="line">    time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/2000/1*esw_FDWZXB-3o2gA4buRpA.jpeg" alt></p><p><img src="https://cdn-images-1.medium.com/max/2000/1*cZY2BoVrw7OSpl2-r-g5yA.jpeg" alt></p><p>So it‚Äôs Responsibility of channel in Go to make the Goroutine runnable again that is blocked on the channel while receiving the data or sending the data.</p><p><em>If you are unfamiliar with Go Scheduler please read this nice introduction about it. <a href="https://morsmachine.dk/go-scheduler" target="_blank" rel="noopener">https://morsmachine.dk/go-scheduler</a></em></p><h2 id="Channel-Structure"><a href="#Channel-Structure" class="headerlink" title="Channel Structure"></a>Channel Structure</h2><p>In Go, the ‚Äúchannel structure‚Äù is the basis of message passing between Goroutine. So What does this channel structure looks like after we create it?</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><em>Buffered Channel Structure after channel creation during runtime.</em><br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chan</span> <span class="keyword">int</span> &#123;</span><br><span class="line">	qcount: <span class="number">0</span>,</span><br><span class="line">	dataqsiz: <span class="number">3</span>,</span><br><span class="line">	buf: *[<span class="number">3</span>]<span class="keyword">int</span> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">	elemsize: <span class="number">8</span>,</span><br><span class="line">	closed: <span class="number">0</span>,</span><br><span class="line">	elemtype: *runtime._type &#123;</span><br><span class="line">		size: <span class="number">8</span>,</span><br><span class="line">		ptrdata: <span class="number">0</span>,</span><br><span class="line">		hash: <span class="number">4149441018</span>,</span><br><span class="line">		tflag: tflagUncommon|tflagExtraStar|tflagNamed,</span><br><span class="line">		align: <span class="number">8</span>,</span><br><span class="line">		fieldalign: <span class="number">8</span>,</span><br><span class="line">		kind: <span class="number">130</span>,</span><br><span class="line">		alg: *(*runtime.typeAlg)(<span class="number">0x568eb0</span>),</span><br><span class="line">		gcdata: *<span class="number">1</span>,</span><br><span class="line">		str: <span class="number">1015</span>,</span><br><span class="line">		ptrToThis: <span class="number">45376</span>,&#125;,</span><br><span class="line">	sendx: <span class="number">1</span>,</span><br><span class="line">	recvx: <span class="number">1</span>,</span><br><span class="line">	recvq: waitq&lt;<span class="keyword">int</span>&gt; &#123;</span><br><span class="line">		first: *sudog&lt;<span class="keyword">int</span>&gt; <span class="literal">nil</span>,</span><br><span class="line">		last: *sudog&lt;<span class="keyword">int</span>&gt; <span class="literal">nil</span>,&#125;,</span><br><span class="line">	sendq: waitq&lt;<span class="keyword">int</span>&gt; &#123;</span><br><span class="line">		first: *sudog&lt;<span class="keyword">int</span>&gt; <span class="literal">nil</span>,</span><br><span class="line">		last: *sudog&lt;<span class="keyword">int</span>&gt; <span class="literal">nil</span>,&#125;,</span><br><span class="line">    lock: runtime.mutex &#123;key: <span class="number">0</span>&#125;,&#125;</span><br></pre></td></tr></table></figure><p></p><p>Looks good, good. But what does this really mean? and from where channel gets its structure. Let‚Äôs look at a few important structs before going any further.</p><h3 id="hchan-struct"><a href="#hchan-struct" class="headerlink" title="hchan struct"></a>hchan struct</h3><p>When we write <code>make(chan int, 3)</code> channel is created from the hchan struct, which has the following fields.</p><p><em>hchan and waitq structs</em><br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	qcount   <span class="keyword">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">	dataqsiz <span class="keyword">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">	buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">	elemsize <span class="keyword">uint16</span></span><br><span class="line">	closed   <span class="keyword">uint32</span></span><br><span class="line">	elemtype *_type <span class="comment">// element type</span></span><br><span class="line">	sendx    <span class="keyword">uint</span>   <span class="comment">// send index</span></span><br><span class="line">	recvx    <span class="keyword">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">	recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">	sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">	<span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Do not change another G's status while holding this lock</span></span><br><span class="line">	<span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">	<span class="comment">// with stack shrinking.</span></span><br><span class="line">	lock mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">	first *sudog</span><br><span class="line">	last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>Lets put descriptions to a few fields that we encountered in the channel structure.</p><p><strong>dataqsize</strong> Is the size of the buffer mentioned above, that is <code>make(chan T, N)</code>, the N.</p><p><strong>elemsize</strong> Is the size of a channel corresponding to a single element.</p><p><strong>buf </strong>is the <em>circular queue where our data is actually stored. (used only for buffered channel)</em></p><p><strong>closed</strong> Indicates whether the current channel is in the closed state. After a channel is created, this field is set to 0, that is, the channel is open; by calling close to set it to 1, the channel is closed.</p><p><strong>sendx</strong> and <strong>recvx</strong> is state field of a ring buffer, which indicates the current index of buffer ‚Äî backing array from where it can send data and receive data.</p><p><strong>recvq</strong> and <strong>sendq</strong> waiting queues, which are used to store the blocked goroutines while trying to read data on the channel or while trying to send data from the channel.</p><p><strong>lock</strong> To lock the channel for each read and write operation as sending and receiving must be mutually exclusive operations.</p><p>So what is this <strong>sudog</strong>?</p><h3 id="sudog-struct"><a href="#sudog-struct" class="headerlink" title="sudog struct"></a>sudog struct</h3><blockquote><p>sudog represent the goroutine.</p></blockquote><p><em>Important Field of sudog struct for channel</em><br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sudog represents a g in a wait list, such as for sending/receiving</span></span><br><span class="line"><span class="comment">// on a channel.</span></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">	g *g</span><br><span class="line"></span><br><span class="line">	<span class="comment">// isSelect indicates g is participating in a select, so</span></span><br><span class="line">	<span class="comment">// g.selectDone must be CAS'd to win the wake-up race.</span></span><br><span class="line">	isSelect <span class="keyword">bool</span></span><br><span class="line">	next     *sudog</span><br><span class="line">	prev     *sudog</span><br><span class="line">	elem     unsafe.Pointer <span class="comment">// data element (may point to stack)</span></span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	c           *hchan <span class="comment">// channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>Let‚Äôs try to wrap our head around the channel structure again step by step. It‚Äôs important to have a clear picture of these as this is what gives channel the power in Go.</p><p><em>Example Code</em><br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goRoutineA</span><span class="params">(a &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	val := &lt;-a</span><br><span class="line">	fmt.Println(<span class="string">"goRoutineA received the data"</span>, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goRoutineB</span><span class="params">(b &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	val := &lt;-b</span><br><span class="line">	fmt.Println(<span class="string">"goRoutineB received the data"</span>, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> goRoutineA(ch)</span><br><span class="line">	<span class="keyword">go</span> goRoutineB(ch)</span><br><span class="line">	ch &lt;- <span class="number">3</span></span><br><span class="line">	time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>What will be the structure of the channel before <strong>line No 22?</strong></p><p><img src="https://cdn-images-1.medium.com/max/2000/1*W6AijkK0xecNtW_jvRU79Q.png" alt="Chan Struct at the runtime"></p><p>Pay attention to highlighted line no 47 and 48 above. Remember <strong>recvq</strong> description from above</p><blockquote><p><strong>recvq </strong>are used to store the blocked goroutines which are trying to read data from the channel.</p></blockquote><p>In Our Example Code before line 22 there are two goroutines (goroutineA and goroutineB) trying to read data from the channel ch</p><p>Since before line 22 on a channel, there is no data we have put on the channel so both the goroutines blocked for receive operation have been wrapped inside the sudog struct and is present on the <strong>recvq </strong>of the channel.</p><blockquote><p>sudog represent the goroutine.</p></blockquote><p>recvq and sendq are basically linked list, which looks basically as below</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*fiFgoUaJ8nV-SQtEjRv2-w.jpeg" alt="Recvq structure"></p><p>These structures are really Important,</p><p>Let‚Äôs see what happens when we try to put the data on the channel ch</p><h2 id="Send-Opertaion-Steps-c-lt-x"><a href="#Send-Opertaion-Steps-c-lt-x" class="headerlink" title="Send Opertaion Steps c &lt;- x"></a>Send Opertaion Steps c &lt;- x</h2><blockquote><p>Underlying types of send Operations on Channel</p></blockquote><ol><li><strong>sending on nil channel</strong></li></ol><p><img src="https://cdn-images-1.medium.com/max/2000/1*tRvxKBqmSjhnWAh1X0o2kA.jpeg" alt></p><p>If we are sending on the nil channel the current goroutine will suspend its operation.</p><p>2<strong>. sending on the closed channel.</strong></p><p><img src="https://cdn-images-1.medium.com/max/2000/1*6QwJEx8opvaNzabRtHMa9A.jpeg" alt></p><p>If we try to send data on the closed channel our goroutine panic.</p><p>3<strong>. A goroutine is blocked on the channel: the data is sent directly to the goroutine.</strong></p><p><img src="https://cdn-images-1.medium.com/max/2000/1*F16kjMMl6Y9W7IYWNAHXrw.jpeg" alt></p><p>This is where recvq structure plays such an important role. If there is any goroutine in the recvq it‚Äôs a <em>waiting receiver, </em>and current write operation to channel can directly pass the value to that receiver. Implementation of the send function.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*HZyaOxBmRRopvrnhrx90VQ.jpeg" alt></p><p>Pay attention to the line number 396 goready(gp, skip+1) the Goroutine which was blocked while waiting for the data has <strong>been made runnable again by calling goready, </strong>and the go scheduler will run the goroutine again.</p><p>4<strong>. Buffered Channel if there is currently space available for hchan.buf: put the data in the buffer.</strong></p><p><img src="https://cdn-images-1.medium.com/max/2476/1*y9l_mrfI80ga6RXiTezREQ.png" alt></p><p><code>chanbuf(c, i)</code> accesses the corresponding memory area.</p><p>Determine if hchan.buf has free space by comparing qcount and dataqsiz. <strong><strong>Enqueue the element by copying the area pointed to by the ep pointer to the ring buffer to send</strong></strong>, and adjust sendx and qcount.</p><ol start="5"><li><strong>The hchan.buf is full</strong></li></ol><p><img src="https://cdn-images-1.medium.com/max/2472/1*q0fyvZEoGKhFhYDgCtPUDg.png" alt></p><p>Create a goroutine object on the current stack</p><p>acquireSudog to put the current goroutine in the park state and then add that goroutine in the sendq of the channel.</p><h2 id="Send-operation-Summary"><a href="#Send-operation-Summary" class="headerlink" title="Send operation Summary"></a>Send operation Summary</h2><ol><li><p><strong>lock</strong> the entire channel structure.</p></li><li><p>determines writes. Try recvq to take a waiting goroutine from the wait queue, then hand the element to be written directly to the goroutine.</p></li><li><p>If recvq is Empty, Determine whether the buffer is available. If available, <strong><strong>copy</strong></strong> (typedmemmove copies a value of type t to dst from src.`) the data from current goroutine to the buffer.<br><em><em>typedmemmove</em></em> internally uses <em>memmove ‚Äî memmove() is used to copy a block of memory from a location to another.</em></p></li><li><p>If the buffer is full then the element to be written is saved in the structure of the currently executing goroutine and the current goroutine is enqueued at <strong>sendq</strong> and suspended, from runtime.</p></li></ol><p>Point number 4 is really Interesting.</p><blockquote><p>If the buffer is full then the element to be written is saved in the structure of the currently executing goroutine.</p></blockquote><p><strong>Read it again, because this is why the unbuffered channel is actually called ‚Äúunbuffered‚Äù even though the ‚Äúhchan‚Äù struct has the ‚Äúbuf‚Äù element associated with it</strong>. Because for an unbuffered channel if there is no receiver and if you try to send data, the data will be saved in the elem of the sudog structure. (Holds true for the buffered channel too).</p><p>Let me give you an example to clarify the point number 4 in more details. Suppose we have the below code.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*oqyZV9Ia-MraRGqvK3WaCg.jpeg" alt="Don‚Äôt run this code it will cause panic in normal mode."><em>Don‚Äôt run this code it will cause panic in normal mode.</em></p><p>What will be the runtime structure of the chan c2 at line number10 ?</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chan</span> <span class="keyword">int</span> &#123;</span><br><span class="line">	qcount: <span class="number">0</span>,</span><br><span class="line">	dataqsiz: <span class="number">0</span>,</span><br><span class="line">	buf: *[<span class="number">0</span>]<span class="keyword">int</span> [],</span><br><span class="line">	elemsize: <span class="number">8</span>,</span><br><span class="line">	closed: <span class="number">0</span>,</span><br><span class="line">	elemtype: *runtime._type &#123;</span><br><span class="line">		size: <span class="number">8</span>,</span><br><span class="line">		ptrdata: <span class="number">0</span>,</span><br><span class="line">		hash: <span class="number">4149441018</span>,</span><br><span class="line">		tflag: tflagUncommon|tflagExtraStar|tflagNamed,</span><br><span class="line">		align: <span class="number">8</span>,</span><br><span class="line">		fieldalign: <span class="number">8</span>,</span><br><span class="line">		kind: <span class="number">130</span>,</span><br><span class="line">		alg: *(*runtime.typeAlg)(<span class="number">0x4bff</span>90),</span><br><span class="line">		gcdata: *<span class="number">1</span>,</span><br><span class="line">		str: <span class="number">775</span>,</span><br><span class="line">		ptrToThis: <span class="number">28320</span>,&#125;,</span><br><span class="line">	sendx: <span class="number">0</span>,</span><br><span class="line">	recvx: <span class="number">0</span>,</span><br><span class="line">	recvq: waitq&lt;<span class="keyword">int</span>&gt; &#123;</span><br><span class="line">		first: *sudog&lt;<span class="keyword">int</span>&gt; <span class="literal">nil</span>,</span><br><span class="line">		last: *sudog&lt;<span class="keyword">int</span>&gt; <span class="literal">nil</span>,&#125;,</span><br><span class="line">	sendq: waitq&lt;<span class="keyword">int</span>&gt; &#123;</span><br><span class="line">		first: *(*sudog&lt;<span class="keyword">int</span>&gt;)(<span class="number">0xc000074000</span>),</span><br><span class="line">		last: *(*sudog&lt;<span class="keyword">int</span>&gt;)(<span class="number">0xc000074000</span>),&#125;,</span><br><span class="line">	lock: runtime.mutex &#123;key: <span class="number">0</span>&#125;,&#125;</span><br></pre></td></tr></table></figure><p>You can see even though we have put int value 2 on the channel the buf does not have the value, but it will be in the sudog structure of the goroutine. As goroutineA tried to send value over to the channel c2 and there were no receiver ready, so the goroutineA will be added to sendq list of the channel c2 and will be parked as it blocks. We can look into the runtime structure of the blocking sendq to verify.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">waitq&lt;<span class="keyword">int</span>&gt; &#123;</span><br><span class="line">	first: *sudog&lt;<span class="keyword">int</span>&gt; &#123;</span><br><span class="line">		g: *(*runtime.g)(<span class="number">0xc000001080</span>),</span><br><span class="line">		isSelect: <span class="literal">false</span>,</span><br><span class="line">		next: *runtime.sudog <span class="literal">nil</span>,</span><br><span class="line">		prev: *runtime.sudog <span class="literal">nil</span>,</span><br><span class="line">		elem: *<span class="number">2</span>,</span><br><span class="line">		acquiretime: <span class="number">0</span>,</span><br><span class="line">		releasetime: <span class="number">0</span>,</span><br><span class="line">		ticket: <span class="number">0</span>,</span><br><span class="line">		parent: *runtime.sudog <span class="literal">nil</span>,</span><br><span class="line">		waitlink: *runtime.sudog <span class="literal">nil</span>,</span><br><span class="line">		waittail: *runtime.sudog <span class="literal">nil</span>,</span><br><span class="line">		c: *(*runtime.hchan)(<span class="number">0xc00001e120</span>),&#125;,</span><br></pre></td></tr></table></figure><p>Now that we have overview of send operation on channel what happens once we send an value to our example code above at line 22.<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="number">3</span></span><br></pre></td></tr></table></figure><p></p><p>As <strong>recvq </strong>of the channel has goroutine in wait state, it will dequeue the first sudog and put the data in that goroutine.</p><blockquote><p>Remember all transfer of value on the go channels happens with the copy of value.</p></blockquote><p><img src="https://cdn-images-1.medium.com/max/2904/1*h7Gv5MhYHL2qrAkhtFG_NQ.png" alt></p><p>What will be the output of the above program ? Just Remember Channel Operates on the copy of value.<br>So in our case channel will copy the value at g into its buffer.</p><blockquote><p><em>Don‚Äôt communicate by sharing memory; share memory by communicating.</em></p></blockquote><p><strong>Output</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;&#123;Ankur 25&#125;</span><br><span class="line">modifyUser Received Value &amp;&#123;Ankur Anand 100&#125;</span><br><span class="line">printUser goRoutine called &amp;&#123;Ankur 25&#125;</span><br><span class="line">&amp;&#123;Anand 100&#125;</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/2000/1*QVu5G0iXTwA5emKOoKvVxA.jpeg" alt></p><h2 id="Receive-Opertaion-Steps-lt-ch"><a href="#Receive-Opertaion-Steps-lt-ch" class="headerlink" title="Receive Opertaion Steps &lt;- ch"></a>Receive Opertaion Steps &lt;- ch</h2><p>Its pretty much the same as the send operations</p><p><img src="https://cdn-images-1.medium.com/max/2432/1*wMt7zNZk8E5S0nKBstGIIA.png" alt></p><h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><blockquote><p>Multiplexing on multiple channel.</p></blockquote><p><img src="https://cdn-images-1.medium.com/max/2000/1*fKqlJBh2QhVlGtlWd1ImrQ.png" alt="select channel Example"></p><p><strong>1.</strong> Operations are mutually exclusive, so <strong>need to acquire the locks on all involved channels in select case, </strong>which is done by sorting the cases by Hchan address to get the <strong>locking order,</strong> so that it does not lock mutexes of all involved channels at once.</p><p><code>sellock(scases, lockorder)</code></p><p>Each scase in the scases array is a struct which contains the kind of operation in the current case and the channel it‚Äôs operating on.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*zVskwl0V0NeSqBFkQ6DYDw.png" alt="scase"></p><p><strong>kind</strong> Is the type of operation in the current case, can be <em>CaseRecv</em>, <em>CaseSend </em>and <em>CaseDefault</em>.</p><p><strong>2.</strong> Calculate the poll order to shuffle all involved channels to provide the pseudo-random guarantee and traverse all the cases in turn according to the poll order one-by-one to see if any of them is ready for communication. This poll order what makes select operations to not necessarily follow the order declared in the program.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*-bYEd5Z0SyJlREIgayXmxA.png" alt="poll order"></p><p><img src="https://cdn-images-1.medium.com/max/2000/1*zgflB5OPpySo9nlJG_PhLQ.png" alt="cases in select"></p><p><strong>3.</strong> The select statement can return as long as there is a channel operation that doesn‚Äôt block, without even need to touch all channels if the selected one is ready.</p><p><strong>4.</strong> If no channel currently responds and there is no default statement, current g must currently hang on the corresponding wait queue for all channels according to their case.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*eP36utLSm2q8kBxMBCuWJQ.png" alt="park goroutine in select case"></p><p><code>sg.isSelect</code> is what indicates that goroutine is participating in the select statement.</p><p><strong>5.</strong> Receive, Send and Close operation during Select Operation is similar to the general operation of Receive, Send and Close on channels.</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Channels is a very powerful and interesting mechanism in Go. But in order to use them effectively you have to understand how they work. Hope this article explain the very fundamental working principle involved with the channels in Go.</p><p>Interested to learn more about Go? Come Join Us at <a href="https://gophersource.com/study-group/" target="_blank" rel="noopener">Go Study Group</a></p><p>The study group is a great way to not only lurk ‚Äòn learn but meet other people in the community. Everyone welcome!</p></div></article><p class="article-content share_center"><strong>Learned something? Share üëè to help others find this article.</strong></p><div class="share share_center"><ul class="share__list"><li class="share__item"><a href="https://twitter.com/share?text=Diving deep into the golang channels&amp;url=http://blog.ankuranand.com/2018/09/29/diving-deep-into-the-golang-channels/index.html&amp;via=in_aanand" target="_blank"><svg class="icon share__icon share__icon--twitter"><use xlink:href="#icon-twitter" xmlns:xlink="https://www.w3.org/1999/xlink"/></svg> Tweet this</a></li></ul></div><div class="box-prev-next clearfix" style="margin-top:10px"><a class="show pull-left" href="/2018/09/02/the-terrible-performance-cost-of-cors-api-on-the-single-page-application-spa/"><i class="icon icon-angle-left"></i> </a><a class="show pull-right" href="/2018/11/29/a-closer-look-at-go-golang-type-system/"><i class="icon icon-angle-right"></i></a></div></div><a id="backTop" class="back-top"><i class="icon-angle-up"></i></a><div class="modal" id="modal"><span id="cover" class="cover hide"></span><div id="modal-dialog" class="modal-dialog hide-dialog"><div class="modal-header"><span id="close" class="btn-close">Close</span></div><hr><div class="modal-body"><ul class="list-toolbox"><li class="item-toolbox"><a class="CIRCLE" href="https://ankuranand.com" rel="noopener noreferrer" target="_self">About</a></li><li class="item-toolbox"><a class="CIRCLE" href="/atom.xml" rel="noopener noreferrer" target="_blank">RSS</a></li><li class="item-toolbox"><a class="CIRCLE" href="/search/" rel="noopener noreferrer" target="_self">Search</a></li></ul></div></div></div><div class="fexo-comments comments-post"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><script>const gitalk = new Gitalk({
  clientID: 'Infinity',
  clientSecret: '9ac2991775db990e81299dfa99a114395b58de3a',
  repo: 'blog',
  owner: 'ankur-anand',
  id: location.pathname.split('/')[4].substring(0, 45),
  // id: location.pathname,
  admin: ['ankur-anand'],
  labels: ['gicomment'],
  // facebook-like distraction free mode
  distractionFreeMode: false
})
gitalk.render('gitalk-container')</script></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.3.0/css/font-awesome.min.css"><script type="text/javascript">function loadScript(e,t){var a=document.createElement("script");a.type="text/javascript",a.readyState?a.onreadystatechange=function(){"loaded"!=a.readyState&&"complete"!=a.readyState||(a.onreadystatechange=null,t())}:a.onload=function(){t()},a.src=e,document.getElementsByTagName("head")[0].appendChild(a)}window.onload=function(){loadScript("/js/bundle.js?235683",function(){})}</script><div class="svg-holder"><svg xmlns="https://www.w3.org/2000/svg"><symbol viewbox="0 0 32 32" id="icon-twitter"><title>twitter</title><path d="M31,6.696c-1.103,0.489-2.291,0.82-3.536,0.969c1.271-0.762,2.247-1.968,2.708-3.404c-1.189,0.705-2.508,1.218-3.909,1.493
          c-1.122-1.196-2.723-1.943-4.493-1.943c-3.398,0-6.154,2.755-6.154,6.154c0,0.483,0.055,0.953,0.159,1.402
          C10.66,11.111,6.125,8.66,3.089,4.937C2.561,5.846,2.256,6.902,2.256,8.031c0,2.135,1.086,4.019,2.737,5.123
          c-1.009-0.031-1.957-0.309-2.786-0.77c-0.002,0.025-0.002,0.052-0.002,0.078c0,2.982,2.122,5.469,4.937,6.034
          c-0.517,0.142-1.061,0.217-1.622,0.217c-0.396,0-0.782-0.039-1.158-0.112c0.784,2.444,3.057,4.225,5.75,4.274
          c-2.105,1.651-4.761,2.635-7.645,2.635c-0.496,0-0.985-0.029-1.467-0.086c2.723,1.746,5.958,2.765,9.434,2.765
          c11.321,0,17.512-9.379,17.512-17.512c0-0.268-0.005-0.533-0.018-0.796C29.131,9.014,30.174,7.93,31,6.696L31,6.696z"/></symbol></svg></div><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script></body>