<!DOCTYPE html><html class="light page-post"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><title>Building A Simple Single Sign On(SSO) Solution From Scratch In Node.js | Ankur Anand</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link rel="canonical" href="http://blog.ankuranand.com/2018/08/28/building-a-simple-single-sign-on-sso-server-and-solution-from-scratch-in-node-js/"><meta name="title" content="Building A Simple Single Sign On(SSO) Solution From Scratch In Node.js"><meta name="referrer" content="unsafe-url"><meta name="author" content="Ankur Anand"><meta name="keywords" content="JavaScript,Node.js,sso,node.js,"><meta name="description" content="IntroductionThe web application uses the browser/server architecture, HTTP as the communication protocol. HTTP is a stateless protocol. Each time the browser requests, the server processes it independ"><meta name="keywords" content="JavaScript,Node.js,sso,node.js"><meta property="og:type" content="article"><meta property="og:title" content="Building A Simple Single Sign On(SSO) Solution From Scratch In Node.js"><meta property="og:url" content="http://blog.ankuranand.com/2018/08/28/building-a-simple-single-sign-on-sso-server-and-solution-from-scratch-in-node-js/"><meta property="og:site_name" content="Ankur Anand"><meta property="og:description" content="IntroductionThe web application uses the browser/server architecture, HTTP as the communication protocol. HTTP is a stateless protocol. Each time the browser requests, the server processes it independ"><meta property="og:locale" content="en"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2000/1*OSPd8iGAa2I-oCN_dtZbtg.jpeg"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2102/1*zDZ0aCP8Z95eGiR7HTpGjg.gif"><meta property="og:updated_time" content="2019-06-09T13:50:30.013Z"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Building A Simple Single Sign On(SSO) Solution From Scratch In Node.js"><meta name="twitter:description" content="IntroductionThe web application uses the browser/server architecture, HTTP as the communication protocol. HTTP is a stateless protocol. Each time the browser requests, the server processes it independ"><meta name="twitter:image" content="https://cdn-images-1.medium.com/max/2000/1*OSPd8iGAa2I-oCN_dtZbtg.jpeg"><meta name="twitter:creator" content="@in_aanand"><meta property="article:author" content="https://ankuranand.com/"><meta name="robots" content="index, follow"><link rel="icon" href="/images/favicon.png"><link href="/css/styles.css?v=c114cbeddx" rel="stylesheet"><link rel="stylesheet" href="/css/personal-style.css"><script type="text/javascript">!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject="ga",e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="//www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script"),ga("create","UA-76643336-2","auto"),ga("send","pageview")</script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css"></head></html><body><span id="toolbox-mobile" class="toolbox-mobile">Blog</span><div class="post-header CENTER"><div class="toolbox"><a class="toolbox-entry" href="/"><span class="toolbox-entry-text">Blog</span> <i class="icon-angle-down"></i> <i class="icon-home"></i></a><ul class="list-toolbox"><li class="item-toolbox"><a class="CIRCLE" href="https://ankuranand.com" rel="noopener noreferrer" target="_self">About</a></li><li class="item-toolbox"><a class="CIRCLE" href="/atom.xml" rel="noopener noreferrer" target="_blank">RSS</a></li><li class="item-toolbox"><a class="CIRCLE" href="/search/" rel="noopener noreferrer" target="_self">Search</a></li></ul></div></div><div class="content content-post CENTER"><article id="post-building-a-simple-single-sign-on-sso-server-and-solution-from-scratch-in-node-js" class="article article-type-post" itemprop="blogPost"><header class="article-header"><h1 class="post-title">Building A Simple Single Sign On(SSO) Solution From Scratch In Node.js</h1><div class="article-meta"><span><i class="icon-calendar"></i> <span>2018.08.28</span> </span><span class="article-author"><i class="icon-user"></i> <span>Ankur Anand</span> </span><span class="article-category"><i class="icon-list"></i> <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a></span></div></header><div class="article-content"><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>The web application uses the browser/server architecture, HTTP as the communication protocol. HTTP is a stateless protocol. Each time the browser requests, the server processes it independently and does not associate with the previous or subsequent request. But it also means that any user can access the server resources through the browser. If you want to protect some resources of the server, you must restrict the browser request; to limit the browser request, you must authenticate the browser request, respond to the legitimate request, ignore Illegal request; to authenticate a browser request, you must be aware of the browser request status. Since the HTTP protocol is stateless, so we let the server and browser maintain a state together, using the mechanism such as ‚ÄòCookies‚Äô or ‚ÄòSessions‚Äô or ‚ÄòJWT‚Äô.</p><p>When we have a single system the state mechanism, through the the login authentication is easy to maintain. But when a single system evolves into multiple system, how do we maintain the state of each individual system, do users have to log in one by one and then log out one by one?</p><p>The golden rule of the good users solution is that, the growing complexity of your architecture should be borne by the system rather than the user. No matter how complex the internals of the web system is, it is a unified whole for the users. That is to say, the entire application group of the user accessing the web system is the same as accessing a single system.</p><p>So how do we write the system using single-system login solution?<br>Remember the Good old ‚ÄòCookies‚Äô solution, but then we hit domain restriction of the cookie street, until we unified the domain names of all subsystems in the web application group under a top-level domain name.</p><blockquote><p>But then, Microservices ate the Cookies</p></blockquote><p>People started using different technologies to build their services sometime utilizing different domains too, where key value of the cookie (JSESSIONID in Java) is different than (session in Node.js), and suddenly the session was not easier to be maintained.</p><p>And, we all started building a new login method to enable login for multi-system application groups. This is single sign-on.</p><h2 id="Single-Sign-On-SSO"><a href="#Single-Sign-On-SSO" class="headerlink" title="Single Sign-On(SSO)"></a>Single Sign-On(SSO)</h2><blockquote><p>The basic working principle on which SSO works is you can log in to a system in a multi-system application group and be authorized in all other systems without having to log in again, including single sign-on and single sign-off.</p></blockquote><p>Going forward we are going to write the same for us, for learning perspective.</p><blockquote><p>Enterprise solutions needs much more efforts than what we we are going to putüòÖ. That‚Äôs a sole reason Enterprise solutions are in business.</p></blockquote><p><strong>So how do we login using SSO?</strong></p><p>At the Heart ‚ù§Ô∏è of SSO we have a single independent authentication server, which can accept security information such as user‚Äôs email, username and password. Other systems do not provide login access and only accept indirect authorization from the authentication server. The indirect authorization is implemented using the token.</p><div style="text-align:center"><div class="github-card" data-user="ankur-anand" data-repo="simple-sso" data-width="400" data-theme="default" data-target data-client-id data-client-secret></div></div><script src="/github-card-lib/githubcard.js"></script><p>I‚Äôm going to use node.js for the code, but you can use any technology the implement the basic principle of the SSO.</p><p><strong>1.</strong> The user accesses the protected resource of system ‚Äússo-consumer‚Äù. ‚Äússo-consumer‚Äù finds that the user is not logged in, jumps to the ‚Äússo-server‚Äù, using his own address as a parameter.<br>We are going to build the express.js middleware to check the same for our request.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isAuthenticated = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// simple check to see if the user is authenicated or not,</span></span><br><span class="line">  <span class="comment">// if not redirect the user to the SSO Server for Login</span></span><br><span class="line">  <span class="comment">// pass the redirect URL as current URL</span></span><br><span class="line">  <span class="comment">// serviceURL is where the sso should redirect in case of valid user</span></span><br><span class="line">  <span class="keyword">const</span> redirectURL = <span class="string">`<span class="subst">$&#123;req.protocol&#125;</span>://<span class="subst">$&#123;req.headers.host&#125;</span><span class="subst">$&#123;req.path&#125;</span>`</span>;</span><br><span class="line">  <span class="keyword">if</span> (req.session.user == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.redirect(</span><br><span class="line">      <span class="string">`http://sso.ankuranand.com:3010/simplesso/login?serviceURL=<span class="subst">$&#123;redirectURL&#125;</span>`</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  next();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = isAuthenticated;</span><br></pre></td></tr></table></figure><p><strong>2.</strong> The SSO authentication server finds that the user is not logged in and directs the user to the login page.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> login = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// The req.query will have the redirect url where we need to redirect after successful</span></span><br><span class="line">  <span class="comment">// login and with sso token.</span></span><br><span class="line">  <span class="comment">// This can also be used to verify the origin from where the request has came in</span></span><br><span class="line">  <span class="comment">// for the redirection</span></span><br><span class="line">  <span class="keyword">const</span> &#123; serviceURL &#125; = req.query;</span><br><span class="line">  <span class="comment">// direct access will give the error inside new URL.</span></span><br><span class="line">  <span class="keyword">if</span> (serviceURL != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="keyword">new</span> URL(serviceURL);</span><br><span class="line">    <span class="keyword">if</span> (alloweOrigin[url.origin] !== <span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">        .status(<span class="number">400</span>)</span><br><span class="line">        .json(&#123; <span class="attr">message</span>: <span class="string">"Your are not allowed to access the sso-server"</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (req.session.user != <span class="literal">null</span> &amp;&amp; serviceURL == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.redirect(<span class="string">"/"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if global session already has the user directly redirect with the token</span></span><br><span class="line">  <span class="keyword">if</span> (req.session.user != <span class="literal">null</span> &amp;&amp; serviceURL != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="keyword">new</span> URL(serviceURL);</span><br><span class="line">    <span class="keyword">const</span> intrmid = encodedId();</span><br><span class="line">    storeApplicationInCache(url.origin, req.session.user, intrmid);</span><br><span class="line">    <span class="keyword">return</span> res.redirect(<span class="string">`<span class="subst">$&#123;serviceURL&#125;</span>?ssoToken=<span class="subst">$&#123;intrmid&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res.render(<span class="string">"login"</span>, &#123;</span><br><span class="line">    title: <span class="string">"SSO-Server | Login"</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Extra Security Pointers:</strong><br>We are checking if the serviceURL that has came as query to the ‚Äòsso-server‚Äô has been registered to use the sso-server‚Äô or not.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> alloweOrigin = &#123;</span><br><span class="line"><span class="string">"http://consumer.ankuranand.in:3020"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">"http://consumertwo.ankuranand.in:3030"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">"http://test.tangledvibes.com:3080"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">"http://blog.tangledvibes.com:3080"</span>: fasle,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>3.</strong> User enters username and password to submit login request.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*OSPd8iGAa2I-oCN_dtZbtg.jpeg" alt="login.ejs"></p><p><strong>4.</strong> The SSO authentication server verifies the user information and creates a session between the user and the sso authentication server. <strong>This is called a global session and creates an authorization token. </strong>The authorization token is a string of random characters. It doesn‚Äôt matter how it is generated. As long as it is not repeated and not easy to forge,</p><p><strong>5.</strong> The SSO authentication server takes the <strong>authorization token</strong> to jump to the initial request address (system ‚Äússo-consumer‚Äù).</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> doLogin = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do the validation with email and password</span></span><br><span class="line">  <span class="comment">// but the goal is not to do the same in this right now,</span></span><br><span class="line">  <span class="comment">// like checking with Datebase and all, we are skiping these section</span></span><br><span class="line">  <span class="keyword">const</span> &#123; email, password &#125; = req.body;</span><br><span class="line">  <span class="keyword">if</span> (!(userDB[email] &amp;&amp; password === userDB[email].password)) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.status(<span class="number">404</span>).json(&#123; <span class="attr">message</span>: <span class="string">"Invalid email and password"</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// else redirect</span></span><br><span class="line">  <span class="keyword">const</span> &#123; serviceURL &#125; = req.query;</span><br><span class="line">  <span class="keyword">const</span> id = encodedId();</span><br><span class="line">  req.session.user = id;</span><br><span class="line">  sessionUser[id] = email;</span><br><span class="line">  <span class="keyword">if</span> (serviceURL == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.redirect(<span class="string">"/"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="keyword">new</span> URL(serviceURL);</span><br><span class="line">  <span class="keyword">const</span> intrmid = encodedId();</span><br><span class="line">  storeApplicationInCache(url.origin, id, intrmid);</span><br><span class="line">  <span class="keyword">return</span> res.redirect(<span class="string">`<span class="subst">$&#123;serviceURL&#125;</span>?ssoToken=<span class="subst">$&#123;intrmid&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Extra Security Pointers:</strong></p><ul><li>Always consider this token as intermediate token and exchange the real data using this token.</li><li>If you are using JWT as the intermediate token please avoid sharing any critical data over this JWT.*</li></ul><p><strong>6</strong>. The ‚Äòsso-consumer‚Äô gets the token and goes to the ‚Äòsso-server‚Äô authentication to check if the token is valid.The ‚ÄòSSO-SERVER‚Äô verifies the token and return another token with user information to the ‚Äússo-consumer‚Äù. The ‚Äússo-consumer‚Äù uses this token to create a session with the user. <strong>This session is called local session.</strong></p><p>Here is a brief sso-consumer middle-ware inside the ‚Äússo-consumer‚Äù application, built using the ‚Äòexpress.js‚Äô</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ssoRedirect = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// check if the req has the queryParameter as ssoToken</span></span><br><span class="line">    <span class="comment">// and who is the referer.</span></span><br><span class="line">    <span class="keyword">const</span> &#123; ssoToken &#125; = req.query;</span><br><span class="line">    <span class="keyword">if</span> (ssoToken != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// to remove the ssoToken in query parameter redirect.</span></span><br><span class="line">      <span class="keyword">const</span> redirectURL = url.parse(req.url).pathname;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> axios.get(</span><br><span class="line">          <span class="string">`<span class="subst">$&#123;ssoServerJWTURL&#125;</span>?ssoToken=<span class="subst">$&#123;ssoToken&#125;</span>`</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            headers: &#123;</span><br><span class="line">              Authorization: <span class="string">"Bearer l1Q7zkOL59cRqWBkQ12ZiGVW2DBL"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">const</span> &#123; token &#125; = response.data;</span><br><span class="line">        <span class="keyword">const</span> decoded = <span class="keyword">await</span> verifyJwtToken(token);</span><br><span class="line">        <span class="comment">// now that we have the decoded jwt, use the,</span></span><br><span class="line">        <span class="comment">// global-session-id as the session id so that</span></span><br><span class="line">        <span class="comment">// the logout can be implemented with the global session.</span></span><br><span class="line">        req.session.user = decoded;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> next(err);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> res.redirect(<span class="string">`<span class="subst">$&#123;redirectURL&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>After the request from the sso-consumer , the sso-server checks the token to find out whether the token exists and expires. The token verification succeeds.</p><p>The SSO-Server in our case we are going to return a signed JWT with user information, after successful validation.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> verifySsoToken = <span class="keyword">async</span> (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> appToken = appTokenFromRequest(req);</span><br><span class="line">  <span class="keyword">const</span> &#123; ssoToken &#125; = req.query;</span><br><span class="line">  <span class="comment">// if the application token is not present or ssoToken request is invalid</span></span><br><span class="line">  <span class="comment">// if the ssoToken is not present in the cache some is</span></span><br><span class="line">  <span class="comment">// smart.</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    appToken == <span class="literal">null</span> ||</span><br><span class="line">    ssoToken == <span class="literal">null</span> ||</span><br><span class="line">    intrmTokenCache[ssoToken] == <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.status(<span class="number">400</span>).json(&#123; <span class="attr">message</span>: <span class="string">"badRequest"</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if the appToken is present and check if it's valid for the application</span></span><br><span class="line">  <span class="keyword">const</span> appName = intrmTokenCache[ssoToken][<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> globalSessionToken = intrmTokenCache[ssoToken][<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// If the appToken is not equal to token given during the sso app registraion or later stage than invalid</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    appToken !== appTokenDB[appName] ||</span><br><span class="line">    sessionApp[globalSessionToken][appName] !== <span class="literal">true</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.status(<span class="number">403</span>).json(&#123; <span class="attr">message</span>: <span class="string">"Unauthorized"</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// checking if the token passed has been generated</span></span><br><span class="line">  <span class="keyword">const</span> payload = generatePayload(ssoToken);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> token = <span class="keyword">await</span> genJwtToken(payload);</span><br><span class="line">  <span class="comment">// delete the itremCache key for no futher use,</span></span><br><span class="line">  <span class="keyword">delete</span> intrmTokenCache[ssoToken];</span><br><span class="line">  <span class="keyword">return</span> res.status(<span class="number">200</span>).json(&#123; token &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Extra Security Pointers:</strong></p><ul><li>Inside ‚Äússo-server‚Äù register each application that‚Äôs going to use the sso-server for authentication and give them some sort of verification header while making a request. This establishes a better security between consumer and ‚Äússo-server‚Äù.</li><li>You can also generate different ‚Äúprivate‚Äù and ‚Äúpublic‚Äù rsa file for each application and let each application verify their JWT with their respective Public Key at the consumer side.*</li></ul><p>You can also define application-level policy at the centralized place.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userDB = &#123;</span><br><span class="line">  <span class="string">"info@ankuranand.com"</span>: &#123;</span><br><span class="line">    password: <span class="string">"test"</span>,</span><br><span class="line">    userId: encodedId(), <span class="comment">// incase you dont want to share the user-email.</span></span><br><span class="line">    appPolicy: &#123;</span><br><span class="line">      sso_consumer: &#123; <span class="attr">role</span>: <span class="string">"admin"</span>, <span class="attr">shareEmail</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      simple_sso_consumer: &#123; <span class="attr">role</span>: <span class="string">"user"</span>, <span class="attr">shareEmail</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>After the user logs in successfully, a session is established with the ‚Äússo authentication server‚Äù and each consumer subsystem. The session established between the user and the ‚Äússo authentication server‚Äù is called a <strong>global session</strong>. The session established between the user and each ‚Äúconsumer subsystem‚Äù is called a <strong>local session</strong>. After the local session is established, the user can access the consumer subsystem protected resources.</p><p><img src="https://cdn-images-1.medium.com/max/2102/1*zDZ0aCP8Z95eGiR7HTpGjg.gif" alt></p><p>‚ÄúLocal session‚Äù and ‚ÄúGlobal session‚Äù both are established.</p><p>Brief look at the functions that sso-client and sso-server that we‚Äôve implemented.</p><p><strong>SSO-Consumer</strong></p><p><strong>1.</strong> The sso-consumer subsystem does not log in to the user request and jumps to the sso server for authentication.<br><strong>2.</strong> Receive the token sent by the sso authentication server.<br><strong>3.</strong> Communicate with sso-server to verify the validity of the token.<br><strong>4.</strong> Receives a JWT, verifies the JWT using the public key.<br><strong>5.</strong> Establish a local session</p><p><strong>Sso-server</strong></p><p><strong>1.</strong> Verify the user‚Äôs login information.<br><strong>2.</strong> Create a global session.<br><strong>3.</strong> Create an authorization token.<br><strong>4.</strong> Send a token with sso-client communication.<br><strong>5.</strong> Verify sso-client token validity.<br><strong>6.</strong> Send a JWT with the user information.</p><p>In summary, there are many options for system integration single sign-on solutions, each of which has its own advantages and adaptation environment. Building one from scratch is an iterative project that needs to analyze the characteristics of each system, including login methods, user information storage and synchronization, etc., and cannot blindly rely on the single way to solve the problem.</p><p>Similarly we can implement the ‚ÄúLogout‚Äù, just we need to consider these three relationship in mind while writing the ‚ÄúLogout‚Äù Functionality.</p><p><strong>1.</strong> Local session exists, global session must exist.<br><strong>2.</strong> Global session exists, local session does not necessarily exist.<br><strong>3.</strong> Global session is destroyed, local session must be destroyed.</p><div style="text-align:center"><div class="github-card" data-user="ankur-anand" data-repo="simple-sso" data-width="400" data-theme="default" data-target data-client-id data-client-secret></div></div><script src="/github-card-lib/githubcard.js"></script></div></article><p class="article-content share_center"><strong>Learned something? Share üëè to help others find this article.</strong></p><div class="share share_center"><ul class="share__list"><li class="share__item"><a href="https://twitter.com/share?text=Building A Simple Single Sign On(SSO) Solution From Scratch In Node.js&amp;url=http://blog.ankuranand.com/2018/08/28/building-a-simple-single-sign-on-sso-server-and-solution-from-scratch-in-node-js/index.html&amp;via=in_aanand" target="_blank"><svg class="icon share__icon share__icon--twitter"><use xlink:href="#icon-twitter" xmlns:xlink="https://www.w3.org/1999/xlink"/></svg> Tweet this</a></li></ul></div><div class="box-prev-next clearfix" style="margin-top:10px"><a class="show pull-left" href="/2018/06/29/es6s-function-destructuring-assignment-is-not-free-lunch/"><i class="icon icon-angle-left"></i> </a><a class="show pull-right" href="/2018/09/02/the-terrible-performance-cost-of-cors-api-on-the-single-page-application-spa/"><i class="icon icon-angle-right"></i></a></div></div><a id="backTop" class="back-top"><i class="icon-angle-up"></i></a><div class="modal" id="modal"><span id="cover" class="cover hide"></span><div id="modal-dialog" class="modal-dialog hide-dialog"><div class="modal-header"><span id="close" class="btn-close">Close</span></div><hr><div class="modal-body"><ul class="list-toolbox"><li class="item-toolbox"><a class="CIRCLE" href="https://ankuranand.com" rel="noopener noreferrer" target="_self">About</a></li><li class="item-toolbox"><a class="CIRCLE" href="/atom.xml" rel="noopener noreferrer" target="_blank">RSS</a></li><li class="item-toolbox"><a class="CIRCLE" href="/search/" rel="noopener noreferrer" target="_self">Search</a></li></ul></div></div></div><div class="fexo-comments comments-post"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><script>const gitalk = new Gitalk({
  clientID: 'Infinity',
  clientSecret: '9ac2991775db990e81299dfa99a114395b58de3a',
  repo: 'blog',
  owner: 'ankur-anand',
  id: location.pathname.split('/')[4].substring(0, 45),
  // id: location.pathname,
  admin: ['ankur-anand'],
  labels: ['gicomment'],
  // facebook-like distraction free mode
  distractionFreeMode: false
})
gitalk.render('gitalk-container')</script></div><script type="text/javascript">function loadScript(e,t){var a=document.createElement("script");a.type="text/javascript",a.readyState?a.onreadystatechange=function(){"loaded"!=a.readyState&&"complete"!=a.readyState||(a.onreadystatechange=null,t())}:a.onload=function(){t()},a.src=e,document.getElementsByTagName("head")[0].appendChild(a)}window.onload=function(){loadScript("/js/bundle.js?235683",function(){})}</script><div class="svg-holder"><svg xmlns="https://www.w3.org/2000/svg"><symbol viewbox="0 0 32 32" id="icon-twitter"><title>twitter</title><path d="M31,6.696c-1.103,0.489-2.291,0.82-3.536,0.969c1.271-0.762,2.247-1.968,2.708-3.404c-1.189,0.705-2.508,1.218-3.909,1.493
          c-1.122-1.196-2.723-1.943-4.493-1.943c-3.398,0-6.154,2.755-6.154,6.154c0,0.483,0.055,0.953,0.159,1.402
          C10.66,11.111,6.125,8.66,3.089,4.937C2.561,5.846,2.256,6.902,2.256,8.031c0,2.135,1.086,4.019,2.737,5.123
          c-1.009-0.031-1.957-0.309-2.786-0.77c-0.002,0.025-0.002,0.052-0.002,0.078c0,2.982,2.122,5.469,4.937,6.034
          c-0.517,0.142-1.061,0.217-1.622,0.217c-0.396,0-0.782-0.039-1.158-0.112c0.784,2.444,3.057,4.225,5.75,4.274
          c-2.105,1.651-4.761,2.635-7.645,2.635c-0.496,0-0.985-0.029-1.467-0.086c2.723,1.746,5.958,2.765,9.434,2.765
          c11.321,0,17.512-9.379,17.512-17.512c0-0.268-0.005-0.533-0.018-0.796C29.131,9.014,30.174,7.93,31,6.696L31,6.696z"/></symbol></svg></div><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script></body>